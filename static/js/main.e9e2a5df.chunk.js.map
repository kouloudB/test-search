{"version":3,"sources":["types/Account.ts","actions/OnlineSearch.ts","actions/OfflineSearch.ts","containers/Home.tsx","actions/Accounts.ts","containers/Login.tsx","App.tsx","serviceWorkerRegistration.ts","reducers/accountsReducer.ts","reducers/index.ts","store/index.ts","index.tsx"],"names":["GET_ACCOUNTS","OFFLINE_STATUS","ACCOUNT_SEARCH_ONLINE","ACCOUNT_SEARCH_OFFLINE","onlineSearch","url","keyword","action_type","dispatch","fetch","then","response","json","results","type","payload","offlineSearch","cache_name","cache_request","a","caches","open","match","filteredData","filter","item","city","includes","Home","accounts","useSelector","state","accountsReducer","isConnected","useDispatch","useState","consCach","setConsCach","handleAccountsSearch","event","undefined","toString","target","value","console","log","useEffect","meta","offline","effect","method","commit","style","display","alignItems","width","flexDirection","onChange","map","i","Login","history","useHistory","onClick","push","App","path","component","isLocalhost","Boolean","window","location","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","controller","onUpdate","onSuccess","catch","error","initialState","id","combineReducers","action","online","middleWares","createSagaMiddleware","ReduxThunk","logger","offlineConfig","discard","retries","status","options","axios","Promise","resolve","data","store","createStore","reducers","compose","applyMiddleware","ReactDOM","render","document","getElementById","URL","process","href","origin","addEventListener","headers","contentType","get","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration"],"mappings":"8NAOaA,EAAe,eAGfC,EAAgB,yBAChBC,EAAuB,wBACvBC,EAAwB,yBCVxBC,EAAe,SAACC,EAAaC,EAAiBC,GACvD,OAAO,SAACC,GACNC,MAAMJ,GACLK,MAAK,SAAAC,GAAQ,OAAIA,EAASC,UAC1BF,MAAK,YAAiB,IAAdG,EAAa,EAAbA,QACLL,EAAS,CACLM,KAAMP,EACNQ,QAASF,SCPVG,EAAgB,SACzBV,EACAW,EACAC,EACAX,GACA,8CAAO,WAAOC,GAAP,SAAAW,EAAA,sEACaC,OAAOC,KAAKJ,GADzB,cAEDK,MAAMJ,GACXR,MAAK,SAAAC,GACH,cAAOA,QAAP,IAAOA,OAAP,EAAOA,EAAUC,OACnBF,MAAK,YAAe,IACXa,EADU,EAAXV,QACwBW,QAAO,SAAEC,GAClC,OAAOA,EAAKC,KAAKC,SAASrB,MAE9BE,EAAS,CACLM,KAAMP,EACNQ,QAASQ,UAXV,2CAAP,uDCAElB,EAAM,uDA8DGuB,MA7Df,WACE,IAAMC,EAAWC,aAAY,SAACC,GAAD,OAAyBA,EAAMC,gBAAgBH,YACtEI,EAAcH,aAAY,SAACC,GAAD,OAAyBA,EAAMC,gBAAgBC,eACzEzB,EAAW0B,cAHH,EAKkBC,mBAAS,IAL3B,mBAKNC,EALM,KAKIC,EALJ,KAORC,EAAoB,uCAAG,WAAOC,GAAP,SAAApB,EAAA,0DACxBc,EADwB,gCAELb,OAAOC,KAAK,kBAFP,cAGnBC,MAAMjB,GACXK,MAAK,SAAAC,GAEH,OADD0B,OAAsBG,GAAV7B,EAAqB,YAAa,sBAAcA,QAAd,IAAcA,OAAd,EAAcA,EAAU8B,aACrE,OAAO9B,QAAP,IAAOA,OAAP,EAAOA,EAAUC,OACnBF,MAAK,YAAc,EAAXG,cAGTL,EAASJ,EACPC,EACAkC,EAAMG,OAAOC,MACbzC,IAEF0C,QAAQC,IAAI,gBAfa,wCAiBLzB,OAAOC,KAAK,kBAjBP,eAkBnBC,MAAMjB,GACXK,MAAK,SAAAC,GAEH,OADD0B,OAAsBG,GAAV7B,EAAqB,YAAa,uBAAeA,QAAf,IAAeA,OAAf,EAAeA,EAAU8B,aACtE,OAAO9B,QAAP,IAAOA,OAAP,EAAOA,EAAUC,OACnBF,MAAK,YAAc,EAAXG,cAGTL,EAASQ,EACPuB,EAAMG,OAAOC,MACb,iBACAtC,EACAF,IAEFyC,QAAQC,IAAI,kBA/Ba,4CAAH,sDAwC1B,OALAC,qBAAU,WACRtC,EChDyC,CAC3CM,KAAM,eACNC,QAAS,GACTgC,KAAM,CACJC,QAAS,CACPC,OAAQ,CAAE5C,ID2CSA,EC3CC6C,OAAQ,OAC5BC,OAAQ,CAAErC,KAAMd,EAAc+C,KAAM,UD4CrC,IAGD,sBAAKK,MAAO,CAACC,QAAQ,OAAQC,WAAW,SAAUC,MAAO,QAASC,cAAc,UAAhF,UACE,4BAAIvB,EAAa,SAAU,YAC3B,4BAAI,aAAaG,IACjB,uBAAOtB,KAAK,OAAO2C,SAAUnB,IAC3B,6BACGT,EAAS6B,KAAI,WAASC,GAAT,IAAEjC,EAAF,EAAEA,KAAF,OACZ,6BAAaA,GAAJiC,YE3CNC,MAhBf,WAEE,IAAMC,EAAUC,cAOhB,OACE,8BACE,wBAAQC,QAPO,WACjBF,EAAQG,KAAK,UAMX,sBCISC,MAbf,WACE,OACE,cAAC,IAAD,UACA,8BACE,eAAC,IAAD,WACE,cAAC,IAAD,CAAOC,KAAK,QAAQC,UAAWvC,IAC/B,cAAC,IAAD,CAAOsC,KAAK,IAAIC,UAAWP,YCC7BQ,EAAcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASlD,MAAM,2DA8CnC,SAASmD,EAAgBC,EAAeC,GACtCC,UAAUC,cACPC,SAASJ,GACThE,MAAK,SAACqE,GACLA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBlD,QACf6C,UAAUC,cAAcO,YAI1BxC,QAAQC,IACN,+GAKE8B,GAAUA,EAAOU,UACnBV,EAAOU,SAASN,KAMlBnC,QAAQC,IAAI,sCAGR8B,GAAUA,EAAOW,WACnBX,EAAOW,UAAUP,WAO5BQ,OAAM,SAACC,GACN5C,QAAQ4C,MAAM,4CAA6CA,M,2CChG3DC,EAA8B,CAClC5D,SAAU,GACV6D,GAAI,GACJzD,aAAa,GCPA0D,gCAAgB,CAC3B3D,gBDSW,WAGE,IAFfD,EAEc,uDAFS0D,EACvBG,EACc,uCACd,OAAQA,EAAO9E,MACb,KAAKd,EAOL,KAAKE,EACH,OAAO,2BACF6B,GADL,IAEEF,SAAU+D,EAAO7E,QACjBkB,aAAa,IAEjB,KAAK9B,EACH,OAAO,2BACF4B,GADL,IAEEF,SAAU+D,EAAO7E,UAGpB,KAAKd,EACJ,OAAO,2BACF8B,GADL,IAEEE,YAAa2D,EAAO7E,QAAQ8E,SAIhC,QACE,OAAO9D,M,2DEjCP+D,EAAc,CAFGC,cAEcC,IAAWC,KAQ1CtB,GAPkB,2BACnBuB,KADmB,IAEtBC,QAAS,SAACX,EAA2BI,EAAaQ,GAAqB,IAC7DzF,EAAa6E,EAAb7E,SACR,OAAQA,GAAYA,EAAS0F,QAAU,KAAQD,EAAU,MAG9C,CACbnD,OAAQ,SAACA,EAAa2C,GACpBhD,QAAQC,IAAR,+BAAoC+C,EAAO9E,OADI,IAEvCT,EAAoB4C,EAApB5C,IAAQiG,EAF+B,YAEnBrD,EAFmB,SAY7C,OATUsD,IAAM,aACdlG,IAAKA,GACFiG,IACF5F,MAAK,SAAUC,GAChB,OAAO6F,QAAQC,QAAQ9F,EAAS+F,KAAK7F,YAEtC0E,OAAM,SAAUC,GACb,MAAMA,QAMHmB,EAAQC,sBACnBC,EACDC,kBACCC,kBAAe,WAAf,EAAmBjB,GACnB9C,kBAAQ2B,KChCVqC,IAASC,OACP,cAAC,IAAD,CAAUN,MAAOA,EAAjB,SACE,cAAC,EAAD,MAEFO,SAASC,eAAe,SJYnB,SAAkBxC,GAEvB,GAAK,kBAAmBC,UAAW,CAIjC,GADkB,IAAIwC,IAAIC,eAAwB/C,OAAOC,SAAS+C,MACpDC,SAAWjD,OAAOC,SAASgD,OAMvC,YALA3E,QAAQC,IAAI,KAQdyB,OAAOkD,iBAAiB,QAAQ,WAC9B,IAAM9C,EAAK,UAAM2C,eAAN,sBAEPjD,IAgEV,SAAiCM,EAAeC,GAE9ClE,MAAMiE,EAAO,CACX+C,QAAS,CAAE,iBAAkB,YAE5B/G,MAAK,SAACC,GAGL,IAAM+G,EAAc/G,EAAS8G,QAAQE,IAAI,gBAEnB,MAApBhH,EAAS0F,QACO,MAAfqB,IAA8D,IAAvCA,EAAYE,QAAQ,cAK5ChD,UAAUC,cAAcgD,MAAMnH,MAAK,SAACqE,GAGlCA,EAAa+C,aAAapH,MAAK,WAG7B4D,OAAOC,SAASwD,eAKpBtD,EAAgBC,EAAOC,MAG1BY,OAAM,WAEL3C,QAAQC,IAAI,oEA9FVmF,CAAwBtD,EAAOC,GAI/BC,UAAUC,cAAcgD,MAAMnH,MAAK,WACjCkC,QAAQC,IACN,+GAMJ4B,EAAgBC,EAAOC,OIzC/BsD,I","file":"static/js/main.e9e2a5df.chunk.js","sourcesContent":["export interface Account{\n    results: Array<any>;\n    city: string;\n    address_1: string;\n    [key: string]: string | number | object;\n}\n\nexport const GET_ACCOUNTS = \"GET_ACCOUNTS\";\nexport const GET_ACCOUNTS_COMMIT = \"GET_ACCOUNTS_COMMIT\"\nexport const GET_ACCOUNTS_ROLLBACK= \"GET_ACCOUNTS_ROLLBACK\"\nexport const OFFLINE_STATUS= \"Offline/STATUS_CHANGED\"\nexport const ACCOUNT_SEARCH_ONLINE= \"ACCOUNT_SEARCH_ONLINE\"\nexport const ACCOUNT_SEARCH_OFFLINE= \"ACCOUNT_SEARCH_OFFLINE\"\n\nexport interface GetAccountsAction {\n    type: typeof GET_ACCOUNTS;\n    payload: Account[]\n}\n\nexport interface SearchAccountsOnlineAction {\n    type: typeof ACCOUNT_SEARCH_ONLINE;\n    payload: Account[]\n}\nexport interface SearchAccountsOfflineAction {\n    type: typeof ACCOUNT_SEARCH_OFFLINE;\n    payload: Account[]\n}\nexport interface GetOfflineAction {\n    type: typeof OFFLINE_STATUS;\n    payload: any \n}\nexport type AccountActionTypes =  GetAccountsAction | SearchAccountsOnlineAction | SearchAccountsOfflineAction | GetOfflineAction;","import { Dispatch } from \"redux\"\n\nexport const onlineSearch = (url: string, keyword: string, action_type: string) => {\n    return (dispatch: Dispatch) => {\n      fetch(url)\n      .then(response => response.json())\n      .then(({ results}) => {\n          dispatch({\n              type: action_type,\n              payload: results,\n            });\n      })\n    }\n}\n  \n","import { Dispatch } from \"redux\"\n\nexport const offlineSearch = (\n    keyword: string,\n    cache_name: string, \n    cache_request: string, \n    action_type: string) => {\n    return async (dispatch: Dispatch) => {\n    const cache = await caches.open(cache_name);\n    cache.match(cache_request)\n    .then(response=>{ \n       return response?.json()\n    .then(({ results})=>{\n        const filteredData = results.filter(( item: any) =>{\n            return item.city.includes(keyword)\n        });\n        dispatch({\n            type: action_type,\n            payload: filteredData,\n        });\n    })\n   })\n    \n    }\n}\n  \n","import React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux'\nimport { RootReducers } from '../store';\nimport { getAccounts } from '../actions/Accounts';\nimport { onlineSearch } from '../actions/OnlineSearch';\nimport { offlineSearch } from '../actions/OfflineSearch';\nimport { ACCOUNT_SEARCH_ONLINE, ACCOUNT_SEARCH_OFFLINE, GET_ACCOUNTS} from '../types/Account'\nconst url = \"https://api.fda.gov/food/enforcement.json?limit=1000\";\nfunction Home() {\n  const accounts = useSelector((state: RootReducers) => state.accountsReducer.accounts)\n  const isConnected = useSelector((state: RootReducers) => state.accountsReducer.isConnected)\n  const dispatch = useDispatch();\n  const excludeColumns: string[] = [];\n  const  [consCach, setConsCach]= useState('')\n\n  const handleAccountsSearch = async (event : React.ChangeEvent<HTMLInputElement>)=>{\n    if(isConnected){\n      const cache = await caches.open('accounts-cache');\n      cache.match(url)\n      .then(response=>{ \n        setConsCach(response==undefined? 'undefined': 'online data'+response?.toString())\n         return response?.json()\n      .then(({ results})=>{\n         \n      })})\n      dispatch(onlineSearch(\n        url, \n        event.target.value, \n        ACCOUNT_SEARCH_ONLINE,\n        ))\n      console.log('>>> from API')\n    }else{\n      const cache = await caches.open('accounts-cache');\n      cache.match(url)\n      .then(response=>{ \n        setConsCach(response==undefined? 'undefined': 'offline data'+response?.toString())\n         return response?.json()\n      .then(({ results})=>{\n         \n      })})\n      dispatch(offlineSearch(\n        event.target.value, \n        'accounts-cache', \n        url,\n        ACCOUNT_SEARCH_OFFLINE\n        ))\n      console.log('>>> from CACHE')\n    }\n       \n  }\n  useEffect(()=>{\n    dispatch(getAccounts(url))\n    \n  }, [])\n \n  return (\n    <div style={{display:'flex', alignItems:'center', width: '100vw', flexDirection:'column'}}>\n      <p>{isConnected? \"online\": \"offline\"}</p>\n      <p>{\"consCach  \"+consCach}</p>\n      <input type=\"text\" onChange={handleAccountsSearch} />\n        <ul>\n          {accounts.map(({city}, i)=> \n            <li key={i}>{city}</li>\n          )}\n        </ul>\n    </div>\n  );\n}\n\nexport default Home;\n","import { Dispatch } from \"redux\"\nimport {  GET_ACCOUNTS, AccountActionTypes, GET_ACCOUNTS_ROLLBACK, GET_ACCOUNTS_COMMIT} from \"../types/Account\"\n\nexport const getAccounts = (url: string) => ({\n  type: 'GET_ACCOUNTS',\n  payload: [],\n  meta: {\n    offline: {\n      effect: { url: url, method: 'GET'},\n      commit: { type: GET_ACCOUNTS, meta: {} }\n    }\n  }\n  });\n  \n","import React from 'react';\nimport { useHistory } from 'react-router-dom';\n\nfunction Login() {\n\n  const history = useHistory();\n\n  const handleLogin= ()=>{\n    history.push('/home')\n    \n  }\n \n  return (\n    <div>\n      <button onClick={handleLogin}>Login</button>\n    </div>\n  );\n}\n\nexport default Login;\n","import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Home from './containers/Home';\nimport Login from './containers/Login';\n\nfunction App() {\n  return (\n    <Router>\n    <div>\n      <Switch>\n        <Route path=\"/home\" component={Home} />\n        <Route path=\"/\" component={Login} />\n      </Switch>\n    </div>\n  </Router>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n\n  if ( 'serviceWorker' in navigator) {\n\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      console.log('2');\n\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n\n\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n  \n\n          registration.unregister().then(() => {\n    \n\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n\n","import {  Account, AccountActionTypes, GET_ACCOUNTS, ACCOUNT_SEARCH_ONLINE, ACCOUNT_SEARCH_OFFLINE, OFFLINE_STATUS } from '../types/Account'\ninterface DefaultStateI{\n  accounts: Account[] ,\n  id: string,\n  isConnected: boolean\n}\n\nconst initialState: DefaultStateI = {\n  accounts: [],\n  id: '',\n  isConnected: true\n}\n\nexport default function orderReducer(\n  state : DefaultStateI= initialState,\n  action: AccountActionTypes\n): DefaultStateI{\n  switch (action.type) {\n    case GET_ACCOUNTS: {\n      return {\n        ...state,\n        accounts: action.payload,\n        isConnected: true\n      }\n    }\n    case ACCOUNT_SEARCH_ONLINE:{\n      return {\n        ...state,\n        accounts: action.payload,\n        isConnected: true\n      }}\n    case ACCOUNT_SEARCH_OFFLINE:{\n      return {\n        ...state,\n        accounts: action.payload,\n      }\n     } \n     case OFFLINE_STATUS:{\n      return {\n        ...state,\n        isConnected: action.payload.online\n      }\n     } \n     \n    default:\n      return state\n  }\n}","import { combineReducers } from \"redux\";\nimport accountsReducer from \"./accountsReducer\";\n\nexport default combineReducers({\n    accountsReducer,\n});\n","import { createStore, applyMiddleware,compose } from \"redux\";\nimport createSagaMiddleware from \"redux-saga\";\nimport ReduxThunk from \"redux-thunk\";\nimport reducers from \"../reducers\";\nimport logger from 'redux-logger'\nimport axios from 'axios';\nimport { offline } from '@redux-offline/redux-offline';\nimport offlineConfig from '@redux-offline/redux-offline/lib/defaults';\nimport { getAccounts } from \"../actions/Accounts\";\n\nconst sagaMiddleware = createSagaMiddleware();\n\nconst middleWares = [sagaMiddleware, ReduxThunk,logger]\nconst reduxOfflineConfig = {\n  ...offlineConfig,\n  discard: (error: { response: any; }, action: any, retries: number) => {\n    const { response } = error;\n    return (response && response.status >= 400) || retries > 10;\n  },\n};\nconst config = {\n  effect: (effect: any, action: { type: any; }) => {\n    console.log(`Executing effect for ${action.type}`);\n    const { url, ...options } = effect;\n    const res = axios({\n        url: url,\n        ...options\n      }).then(function (response) {\n        return Promise.resolve(response.data.results);\n      })\n      .catch(function (error) {\n          throw(error);\n      });\n      return res\n  }\n}\n\nexport const store = createStore(\n  reducers,\n compose(\n  applyMiddleware(...middleWares),\n  offline(config))\n)\n\nexport type RootReducers = ReturnType<typeof reducers>\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport { Provider } from 'react-redux';\nimport { store } from './store';\n\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n);\n\nserviceWorkerRegistration.register();\n"],"sourceRoot":""}